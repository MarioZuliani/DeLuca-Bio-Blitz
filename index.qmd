---
title: "Species Index"
engine: knitr
TOC: false
freeze: false
listing:
  contents: species
  sort: title
  filter-ui: [title, categories, description]
  categories: false
  fields: [title, categories, description, image]   # <- show the chips on cards
execute:
  echo: false
  warning: false
  message: false
---

### Welcome to the DeLuca BioBlitz Site

Use the filters to browse species.

## Species

::: column-margin
### Browse by Class

```{r, echo=FALSE, results='asis'}
library(yaml); library(purrr); library(dplyr); library(utils)

`%||%` <- function(a,b) if (is.null(a) || identical(a, "")) b else a

plant_classes <- c(
  "magnoliopsida","liliopsida","pinopsida","polypodiopsida",
  "gnetopsida","equisetopsida","lycopodiopsida","bryopsida"
)

kingdom_of <- function(cls) {
  if (is.null(cls) || is.na(cls) || !nzchar(cls)) return(NA_character_)
  x <- tolower(trimws(cls))
  if (x %in% plant_classes) "Plants" else "Animals"
}

read_front <- function(path){
  x <- readLines(path, warn = FALSE)
  if (length(x) < 3 || trimws(x[1]) != "---") return(NULL)
  end <- which(x[-1] == "---")[1] + 1
  fm  <- yaml::yaml.load(paste(x[2:(end-1)], collapse = "\n"))
  cats <- fm$categories %||% list()

  raw_class <- fm$tax_class %||% NA_character_
  tibble(
    Kingdom = kingdom_of(raw_class),
    Class   = raw_class,
    Order   = fm$tax_order  %||% (if (length(cats) >= 2) cats[[2]] else NA_character_),
    Family  = fm$tax_family %||% (if (length(cats) >= 3) cats[[3]] else NA_character_)
  )
}

files <- list.files("species", pattern="\\.qmd$", full.names = TRUE)
meta  <- map(files, read_front) |> compact() |> bind_rows()

html <- '<div id="facet-menu">'

kingdoms <- intersect(c("Plants","Animals"), sort(unique(na.omit(meta$Kingdom))))
for (kg in kingdoms) {

  kg_n <- sum(meta$Kingdom == kg, na.rm = TRUE)
  html <- paste0(
    html, '<details class="facet-dd"><summary>', kg,
    ' <span class="count">(', kg_n, ')</span></summary>'
  )

  # --- loop through Classes inside this Kingdom ---
  classes <- sort(unique(na.omit(meta$Class[meta$Kingdom == kg])))
  for (cls in classes) {
    cls_n <- sum(meta$Kingdom == kg & meta$Class == cls, na.rm = TRUE)

    ords <- sort(unique(na.omit(meta$Order [meta$Kingdom == kg & meta$Class == cls])))
    fams <- sort(unique(na.omit(meta$Family[meta$Kingdom == kg & meta$Class == cls])))

    ord_n <- setNames(
      vapply(ords, function(o) sum(meta$Kingdom == kg & meta$Class == cls & meta$Order  == o, na.rm = TRUE), integer(1)),
      ords
    )
    fam_n <- setNames(
      vapply(fams, function(f) sum(meta$Kingdom == kg & meta$Class == cls & meta$Family == f, na.rm = TRUE), integer(1)),
      fams
    )

    # per-class collapsible block
    html <- paste0(
      html, '<details class="facet-sub"><summary>', cls,
      ' <span class="count">(', cls_n, ')</span></summary>'
    )

    if (length(ords)) {
      html <- paste0(
        html,
        '<div class="facet-hd">Orders</div><ul class="facet-list">',
        paste0(
          '<li><a href="?category=', URLencode(ords, reserved = TRUE), '">', ords,
          '</a><span class="count">(', ord_n[ords], ')</span></li>', collapse=''
        ),
        '</ul>'
      )
    }

    if (length(fams)) {
      html <- paste0(
        html,
        '<div class="facet-hd">Families</div><ul class="facet-list">',
        paste0(
          '<li><a href="?category=', URLencode(fams, reserved = TRUE), '">', fams,
          '</a><span class="count">(', fam_n[fams], ')</span></li>', collapse=''
        ),
        '</ul>'
      )
    }

    html <- paste0(html, '</details>')  # close .facet-sub
  }

  html <- paste0(html, '</details>')    # close Kingdom
}

html <- paste0(html, '</div>')
knitr::asis_output(html)


```
:::

```{=html}
<script>
(function () {
  // read ?category=... or ?q=...
  const p = new URLSearchParams(window.location.search);
  const term = p.get('category') || p.get('q');
  if (!term) return;

  // find the listing's search input (works across themes)
  const findInput = () =>
    document.querySelector(
      '.quarto-listing .quarto-listing-filter input, input.search-form-control, input[placeholder="Filter"]'
    );

  // set the value + fire the events Quarto/List.js listen for
  const apply = () => {
    const input = findInput();
    if (!input) return false;
    input.value = term;
    ['input','keyup','change'].forEach(evt =>
      input.dispatchEvent(new Event(evt, { bubbles: true }))
    );
    return true;
  };

  // wait until the listing JS is fully initialized, then apply
  const whenReady = (fn, tries = 40, everyMs = 100) => {
    if (fn()) return;
    let n = 0;
    const timer = setInterval(() => {
      if (fn() || ++n >= tries) clearInterval(timer);
    }, everyMs);
  };

  // run after load, then poll briefly until listeners are attached
  window.addEventListener('load', () => whenReady(apply));

  // optional: scroll to the list after filtering
  window.addEventListener('load', () => {
    const list = document.querySelector('.quarto-listing, .listing');
    if (list) list.scrollIntoView({ behavior: 'instant', block: 'start' });
  });
})();
</script>
```
