---
title: "Species Index"
engine: knitr
TOC: false
freeze: false
listing:
  contents: species
  sort: title
  filter-ui: [title, categories, description]
  categories: false
  fields: [title, categories, description, image]   # <- show the chips on cards
execute:
  echo: false
  warning: false
  message: false
---

### Welcome to the DeLuca BioBlitz Site

Use the filters to browse species.

## Species
::: {.column-margin}
### Browse by Class
```{r, echo=FALSE, results='asis'}
library(yaml); library(purrr); library(dplyr); library(utils)

`%||%` <- function(a,b) if (is.null(a) || identical(a, "")) b else a

# bucket raw biological classes into the top-level groups used on the site
bucket <- function(cls) {
  if (is.null(cls) || is.na(cls) || !nzchar(cls)) return(NA_character_)
  x <- tolower(trimws(cls))
  plant_classes <- c("magnoliopsida","liliopsida","pinopsida","polypodiopsida",
                     "gnetopsida","equisetopsida","lycopodiopsida","bryopsida")
  if (x %in% plant_classes) return("Plants")
  if (x == "insecta")       return("Insects")
  tools::toTitleCase(x)  # Aves, Reptilia, Mammalia, Amphibia, â€¦
}

read_front <- function(path){
  x <- readLines(path, warn = FALSE)
  if (length(x) < 3 || trimws(x[1]) != "---") return(NULL)
  end <- which(x[-1] == "---")[1] + 1
  fm  <- yaml::yaml.load(paste(x[2:(end-1)], collapse = "\n"))
  cats <- fm$categories %||% list()

  raw_class <- fm$tax_class %||% NA_character_     # the exact biological class
  grp       <- bucket(raw_class) %||% (if (length(cats) >= 1) cats[[1]] else NA_character_)

  tibble(
    Group  = grp,
    Class  = raw_class,  # keep exact class so we can list it inside the group
    Order  = fm$tax_order  %||% (if (length(cats) >= 2) cats[[2]] else NA_character_),
    Family = fm$tax_family %||% (if (length(cats) >= 3) cats[[3]] else NA_character_)
  )
}

files <- list.files("species", pattern="\\.qmd$", full.names = TRUE)
meta  <- map(files, read_front) |> compact() |> bind_rows()

html <- '<div id="facet-menu">'

for (grp in sort(unique(na.omit(meta$Group)))) {

  grp_n <- sum(meta$Group == grp, na.rm = TRUE)

  # DISTINCT INSIDE THIS GROUP
  classes <- sort(unique(na.omit(meta$Class [meta$Group == grp])))
  orders  <- sort(unique(na.omit(meta$Order [meta$Group == grp])))
  fams    <- sort(unique(na.omit(meta$Family[meta$Group == grp])))

  class_n <- setNames(
    vapply(classes, function(c) sum(meta$Group == grp & meta$Class  == c, na.rm = TRUE), integer(1)),
    classes
  )
  ord_n   <- setNames(
    vapply(orders,  function(o) sum(meta$Group == grp & meta$Order  == o, na.rm = TRUE), integer(1)),
    orders
  )
  fam_n   <- setNames(
    vapply(fams,    function(f) sum(meta$Group == grp & meta$Family == f, na.rm = TRUE), integer(1)),
    fams
  )

  html <- paste0(html,
    '<details class="facet-dd"><summary>', grp,
    ' <span class="count">(', grp_n, ')</span></summary>'
  )

  # NEW: Classes (above Orders), only if we have them
  if (length(classes)) {
    html <- paste0(
      html,
      '<div class="facet-hd">Class</div><ul class="facet-list">',
      paste0(
        '<li><a href="?category=', URLencode(classes, reserved = TRUE), '">', classes,
        '</a><span class="count">(', class_n[classes], ')</span></li>',
        collapse = ''
      ),
      '</ul>'
    )
  }

  # Orders
  if (length(orders)) {
    html <- paste0(
      html,
      '<div class="facet-hd">Orders</div><ul class="facet-list">',
      paste0(
        '<li><a href="?category=', URLencode(orders, reserved = TRUE), '">', orders,
        '</a><span class="count">(', ord_n[orders], ')</span></li>',
        collapse = ''
      ),
      '</ul>'
    )
  }

  # Families
  if (length(fams)) {
    html <- paste0(
      html,
      '<div class="facet-hd">Families</div><ul class="facet-list">',
      paste0(
        '<li><a href="?category=', URLencode(fams, reserved = TRUE), '">', fams,
        '</a><span class="count">(', fam_n[fams], ')</span></li>',
        collapse = ''
      ),
      '</ul>'
    )
  }

  html <- paste0(html, '</details>')
}
html <- paste0(html, '</div>')
knitr::asis_output(html)

```
:::

<script>
(function () {
  // read ?category=... or ?q=...
  const p = new URLSearchParams(window.location.search);
  const term = p.get('category') || p.get('q');
  if (!term) return;

  // find the listing's search input (works across themes)
  const findInput = () =>
    document.querySelector(
      '.quarto-listing .quarto-listing-filter input, input.search-form-control, input[placeholder="Filter"]'
    );

  // set the value + fire the events Quarto/List.js listen for
  const apply = () => {
    const input = findInput();
    if (!input) return false;
    input.value = term;
    ['input','keyup','change'].forEach(evt =>
      input.dispatchEvent(new Event(evt, { bubbles: true }))
    );
    return true;
  };

  // wait until the listing JS is fully initialized, then apply
  const whenReady = (fn, tries = 40, everyMs = 100) => {
    if (fn()) return;
    let n = 0;
    const timer = setInterval(() => {
      if (fn() || ++n >= tries) clearInterval(timer);
    }, everyMs);
  };

  // run after load, then poll briefly until listeners are attached
  window.addEventListener('load', () => whenReady(apply));

  // optional: scroll to the list after filtering
  window.addEventListener('load', () => {
    const list = document.querySelector('.quarto-listing, .listing');
    if (list) list.scrollIntoView({ behavior: 'instant', block: 'start' });
  });
})();
</script>




